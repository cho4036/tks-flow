apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: tks-lma-federation
  namespace: argo
spec:
  entrypoint: deployLMA
  arguments:
    parameters:
    - name: site_name
      value: "decapod-refrence"
    - name: logging_component
      value: "loki"
    - name: github_account
      value: "decapod10"
    - name: manifest_repo_url
      value: "https://github.com/decapod10/c3c16juq5-manifests"
    - name: revision
      value: "main"
    - name: organization_id
      value: "o086tb3zc"
    - name: app_prefix
      value: "{{workflow.parameters.site_name}}"
    ##########################
    # For tks-info task #
    ##########################
    - name: tks_info_host
      value: "http://tks-api.tks.svc:9110"
    - name: cluster_id
      value: "c3c16juq5"
    - name: app_group_id
      value: "a60sfxh4v"

  volumes:
  - name: tks-proto-vol
    configMap:
      name: tks-proto
  templates:
  - name: deployLMA
    steps:
    - - name: createNamespace
        template: createNamespace
        arguments:
          parameters:
          - name: target_namespace
            value: lma

    - - name: get-clusters-in-contract
        templateRef:
          name: tks-primary-cluster
          template: sub-get-cluster

    - - name: set-this-to-primary-cluster
        templateRef:
          name: tks-primary-cluster
          template: set-primary-cluster
        arguments:
          parameters:
          - name: primary_cluster
            value: '{{steps.get-clusters-in-contract.outputs.parameters.primary_cluster}}'
          - name: member_clusters
            value: '{{steps.get-clusters-in-contract.outputs.parameters.member_clusters}}'
        when: "{{steps.get-clusters-in-contract.outputs.parameters.primary_cluster}} == null"

    - - name: organization-level-update
        template: primayCluster
        arguments:
          parameters:
          - name: primary_cluster
            value: '{{steps.get-clusters-in-contract.outputs.parameters.primary_cluster}}'
          - name: member_clusters
            value: '{{workflow.parameters.cluster_id}}'
        when: "{{steps.get-clusters-in-contract.outputs.parameters.primary_cluster}} != null && {{workflow.parameters.cluster_id}} != {{steps.get-clusters-in-contract.outputs.parameters.primary_cluster}}"

    - - name: installApps
        templateRef:
          name: lma-federation
          template: deploy

    - - name: GetMyThanosScEndpoint
        template: GetMyThanosScEndpoint
        arguments:
          parameters:
          - name: target_namespace
            value: lma

    - - name: updateEndpointToTksInfo
        templateRef:
          name: tks-update-appgroup
          template: updateTksAppGroup
        arguments:
          parameters:
          - name: endpoints
            value: "{'PROMETHEUS': '{{steps.GetMyThanosScEndpoint.outputs.parameters.my_thanos_sc_ep}}'}"

      # LMA appGroup specific task #
    - - name: collectThanosScEndpoints
        template: collectThanosScEndpoints
        arguments:
          # These params should be moved to global argument? #
          parameters:
          - name: tks_info_host
            value:  "{{ workflow.parameters.tks_info_host }}"
          - name: app_group_id
            value: "{{ workflow.parameters.app_group_id }}"

    - - name: updateDecapodManifestOutwards
        templateRef:
          name: update-decapod-manifest
          template: updateManifest
        arguments:
          parameters:
          - name: action
            value: "insert"
          - name: cluster_name
            value: "{{ workflow.parameters.cluster_id }}"
          - name: app_group
            value: "lma"
          - name: chart
            value: "thanos"
          - name: kv_map_str
            value: "{'querier.stores': '{{steps.GetMyThanosScEndpoint.outputs.parameters.my_thanos_sc_ep}}'}"
        withParam: "{{steps.collectThanosScEndpoints.outputs.parameters.outwards_cluster_list}}"

    - - name: updateDecapodManifestInwards
        templateRef:
          name: update-decapod-manifest
          template: updateManifest
        arguments:
          parameters:
          - name: action
            value: "insert"
          # TODO: modify this to reflect actual cluster name for all cases
          # instead of just using cluster id
          - name: cluster_name
            value: "{{steps.collectThanosScEndpoints.outputs.parameters.cur_cluster_name}}"
          - name: app_group
            value: "lma"
          - name: chart
            value: "thanos"
          ## {"querier.stores": ['endpointA', 'endpointB']}
          - name: kv_map_str
            value: "{{steps.collectThanosScEndpoints.outputs.parameters.inwards_endpoint_map}}"

  #######################
  # Template Definition #
  #######################
  - name: createNamespace
    inputs:
      parameters:
        - name: target_namespace
    container:
      name: create-namespace
      image: harbor-cicd.taco-cat.xyz/tks/hyperkube:v1.18.6
      command:
        - /bin/bash
        - '-c'
        - |
          function log() {
            level=$1
            msg=$2
            date=$(date '+%F %H:%M:%S')
            echo "[$date] $level     $msg"
          }

          kube_secret=$(kubectl get secret -n {{workflow.parameters.cluster_id}} {{workflow.parameters.cluster_id}}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
          echo -e "kube_secret:\n$kube_secret" | head -n 5
          cat <<< "$kube_secret" > /etc/kubeconfig

          kubectl --kubeconfig=/etc/kubeconfig get ns ${TARGET_NAMESPACE}
          if [[ $? =~ 1 ]]; then
            kubectl --kubeconfig=/etc/kubeconfig create ns ${TARGET_NAMESPACE}
            kubectl --kubeconfig=/etc/kubeconfig label ns ${TARGET_NAMESPACE} name=${TARGET_NAMESPACE}
            kubectl --kubeconfig=/etc/kubeconfig label ns ${TARGET_NAMESPACE} taco-tls=enabled
            log "INFO" "${TARGET_NAMESPACE} successfully created."
          fi
      env:
        - name: TARGET_NAMESPACE
          value: '{{inputs.parameters.target_namespace}}'
    activeDeadlineSeconds: 900
    retryStrategy:
      limit: 2

  - name: primayCluster
    inputs:
      parameters:
      - name: primary_cluster
      - name: member_clusters
    container:
      name: logging-target-changer
      image: harbor-cicd.taco-cat.xyz/tks/hyperkube:v1.18.6
      command:
      - /bin/bash
      - '-c'
      - |

        function log() {
          level=$1
          msg=$2
          date=$(date '+%F %H:%M:%S')
          echo "[$date] $level     $msg"
        }

        # Check endpoints from the primary_cluster
        primary_cluster={{inputs.parameters.primary_cluster}}
        echo __${primary_cluster}__
        if [ -z primary_cluster ] || [ primary_cluster="null" ]; then
          primary_cluster={{workflow.parameters.cluster_id}}
        fi

        echo kubectl get secret -n ${primary_cluster} ${primary_cluster}-kubeconfig -o jsonpath="{.data.value}"
        primary_kube_secret=$(kubectl get secret -n ${primary_cluster} ${primary_cluster}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
        echo -e "primary_kube_secret:\n$primary_kube_secret" | head -n 5
        cat <<< "$primary_kube_secret" > kubeconfig

        while [ -z $(kubectl --kubeconfig=kubeconfig get svc -n lma loki-loki-distributed-gateway -o jsonpath="{.status.loadBalancer.ingress[*].hostname}") ]
        do
          echo "Waiting for generating the loadbalancer of LOKI(3s)"
          sleep 3
        done

        LOKI_HOST=$(kubectl --kubeconfig=kubeconfig get svc -n lma loki-loki-distributed-gateway -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")
        LOKI_PORT=$(kubectl --kubeconfig=kubeconfig get svc -n lma loki-loki-distributed-gateway -o jsonpath="{.spec.ports[0].port}")
        THANOS_HOST=$(kubectl --kubeconfig=kubeconfig get svc -n lma loki-loki-distributed-gateway -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")
        THANOS_PORT=$(kubectl --kubeconfig=kubeconfig get svc -n lma loki-loki-distributed-gateway -o jsonpath="{.spec.ports[0].port}")
        THANOS_URL=${THANOS_HOST}:${THANOS_PORT}

        echo "DEBUG: received parameters: {{inputs.parameters.primary_cluster}}:{{inputs.parameters.member_clusters}}:{{workflow.parameters.cluster_id}} "
        echo "DEBUG: for the input i get: $LOKI_HOST $LOKI_PORT $THANOS_HOST $THANOS_PORT"
        exit 0

        # update primary

        kube_secret=$(kubectl get secret -n {{workflow.parameters.cluster_id}} {{workflow.parameters.cluster_id}}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
        echo -e "kube_secret:\n$kube_secret" | head -n 5
        cat <<< "$kube_secret" > /etc/kubeconfig

        kubectl --kubeconfig=/etc/kubeconfig get ns ${TARGET_NAMESPACE}
        if [[ $? =~ 1 ]]; then
          kubectl --kubeconfig=/etc/kubeconfig create ns ${TARGET_NAMESPACE}
          kubectl --kubeconfig=/etc/kubeconfig label ns ${TARGET_NAMESPACE} name=${TARGET_NAMESPACE}
          kubectl --kubeconfig=/etc/kubeconfig label ns ${TARGET_NAMESPACE} taco-tls=enabled
          log "INFO" "${TARGET_NAMESPACE} successfully created."
        fi

    activeDeadlineSeconds: 900
    retryStrategy:
      limit: 2

  - name: GetMyThanosScEndpoint
    inputs:
      parameters:
      - name: target_namespace
    outputs:
      parameters:
      - name: my_thanos_sc_ep
        valueFrom:
          path: /mnt/out/thanos_sc_ep.txt
    volumes:
    - name: out
      emptyDir: {}
    container:
      name: 'get-thanos-ep'
      image: harbor-cicd.taco-cat.xyz/tks/hyperkube:v1.18.6
      envFrom:
      - secretRef:
          name: "git-svc-token"
      env:
        - name: TARGET_NAMESPACE
          value: '{{inputs.parameters.target_namespace}}'
      volumeMounts:
      - name: out
        mountPath: /mnt/out
      command:
        - /bin/bash
        - '-c'
        - |
          kube_secret=$(kubectl get secret -n {{workflow.parameters.cluster_id}} {{workflow.parameters.cluster_id}}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
          echo -e "kube_secret:\n$kube_secret" | head -n 5
          cat <<< "$kube_secret" > /etc/kubeconfig

          THANOS_SC_PORT='10901'
          THANOS_SC_SVC='lma-thanos-external'
          thanos_sc_ep=$(kubectl --kubeconfig=/etc/kubeconfig get svc ${THANOS_SC_SVC} -n ${TARGET_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [[ -z "$thanos_sc_ep" ]]; then
            echo "Error: could not retrieve thanos sidecar endpoint from service resource."
            exit 1
          else
            echo "$thanos_sc_ep:$THANOS_SC_PORT" > /mnt/out/thanos_sc_ep.txt
          fi

  - name: collectThanosScEndpoints
    inputs:
      parameters:
      - name: tks_info_host
      - name: app_group_id
    outputs:
      parameters:
      - name: outwards_cluster_list
        valueFrom:
          path: /mnt/out/cluster_list.txt
      - name: inwards_endpoint_map
        valueFrom:
          path: /mnt/out/inwards_endpoint.txt
      - name: cur_cluster_name
        valueFrom:
          path: /mnt/out/cur_cluster_name.txt
    volumes:
    - name: out
      emptyDir: {}
    script:
      name: 'collect'
      image: harbor-cicd.taco-cat.xyz/tks/centos-tks-api:v1.0
      command: ["python"]
      envFrom:
      - secretRef:
          name: "git-svc-token"
      - secretRef:
          name: "tks-api-secret"       
      volumeMounts:
      - name: out
        mountPath: /mnt/out
      source: |
        import sys
        import os
        import git
        import requests
        import json

        TKS_API_URL = "{{workflow.parameters.tks_info_host}}"
        CLUSTER_ID = "{{workflow.parameters.cluster_id}}"
        #CLUSTER_ID = "caldcde6u"
        #CLUSTER_ID = "c6fk1w3dm"

        def getToken() :
            data = {
                'organizationId' : os.environ['ORGANIZATION_ID'],
                'accountId': os.environ['ACCOUNT_ID'],
                'password' : os.environ['PASSWORD']
            }

            res = requests.post(TKS_API_URL+"/api/1.0/auth/login", json = data )
            if res.status_code != 200 :
                return ''
            resJson = res.json()
            return resJson['user']['token']

        output_cluster_list = []
        temp_map = {}
        inwards_endpoint_list = []
        inwards_endpoint_map = {}
        outwards_endpoint_map = {}

        TOKEN=getToken()

        res = requests.get(TKS_API_URL+"/api/1.0/clusters/" + CLUSTER_ID,
            headers={"Authorization": "Bearer " + TOKEN} )
        if res.status_code != 200 :
            sys.exit('Failed to get cluster')

        cluster = res.json()['cluster']
        print( cluster )
        organizationId = cluster['organizationId']
        cur_cluster_name = cluster['id']

        res = requests.get(TKS_API_URL+"/api/1.0/clusters?organizationId=" + organizationId,
            headers={"Authorization": "Bearer " + TOKEN} )
        if res.status_code != 200 :
            sys.exit('Failed to get clusters')

        clusters = res.json()['clusters']

        print("Iterating over clusters in the same contract...")

        # Iterate over cluster list except current cluster #
        for cluster in clusters:
            if cluster['status'] != "RUNNING":
              continue

            if cluster['id'] != CLUSTER_ID :
              print("*******************************************")
              print("Checking cluster: {}".format(cluster['id']))

              gitBaseUrl = os.environ['GIT_SVC_URL'].replace("http://","")
              print( gitBaseUrl )


              print("Checking if corresponding cluster repo exists..")
              #url = "@github.com/{{workflow.parameters.github_account}}/{}".format(cluster['id'])
              url = "@" + gitBaseUrl + "/" + os.environ['USERNAME'] + "/" + cluster['id']
              print( url )

              repoUrl = "http://" + os.environ['TOKEN'] + url
              try:
                repo = git.Repo.clone_from(repoUrl, './tempcluster')

              except git.exc.GitCommandError as e:
                print(e)
                print("Repo {} doesn't exist. Skipping this cluster..".format(repoUrl))
                continue

              res = requests.get(TKS_API_URL+"/api/1.0/app-groups?clusterId=" + cluster['id'],
                  headers={"Authorization": "Bearer " + TOKEN} )
              if res.status_code != 200 :
                  print( 'Failed to get appgroups for cluster ')
                  continue

              appGroups = res.json()['appGroups']
              print( appGroups ) 

              os.system("rm -rf ./tempcluster")

              # Check if LMA group exists.
              for appGroup in appGroups:
                if appGroup['appGroupType'] == "LMA" :
                  print("Found LMA appGroup: {}".format(appGroup['name']))

                  res = requests.get(TKS_API_URL+"/api/1.0/app-groups/" + appGroup['id'] + "/applications?applicationType=PROMETHEUS",
                      headers={"Authorization": "Bearer " + TOKEN} )
                  if res.status_code != 200 :
                      print( 'Failed to get applications for appgroup')
                      continue

                  applications = res.json()['applications']            
                  if applications :
                    # This is based on the premise that there's only one prometheus per appGroup.
                    endpoint = applications[0]['endpoint']
                    print("Get Thanos-sc endpoint: {}. Appending it to inward list.".format(endpoint))

                    # Add this cluster's endpoint to endpoint map
                    inwards_endpoint_list.append(endpoint)

                    # Add this cluster to outward list so that current ep is updated to this cluster
                    temp_map["name"] = cluster['id']
                    str_json = json.dumps(temp_map)
                    output_cluster_list.append(str_json)


        # Compose profer format to be used as input on next step 
        inwards_endpoint_map['querier.stores'] = inwards_endpoint_list

        ###########################
        # Construct output params #
        ###########################
        len_list = len(output_cluster_list)

        with open("/mnt/out/cluster_list.txt", "w") as f:
          f.write('[')

          print("*** Outwards Cluster List ***")
          for idx, item in enumerate(output_cluster_list, start=1):
            print("item {}: {}".format(idx, item))
            f.write(item.strip("'"))
            if idx < len_list:
              f.write(',')
          f.write(']')

        with open("/mnt/out/inwards_endpoint.txt", "w") as f:
          str_inwards_endpoint = repr(inwards_endpoint_map)
          f.write(str_inwards_endpoint)

        with open("/mnt/out/cur_cluster_name.txt", "w") as f:
          f.write(cur_cluster_name)
