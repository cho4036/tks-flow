apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: serve-java-app
  namespace: argo
spec:
  entrypoint: main
  onExit: exit-handler
  volumes:
  - name: tks-proto-vol
    configMap:
      name: tks-proto
  arguments:
    parameters:
    # Param "task_type"
    # options: build/deploy/all
    - name: task_type
      value: "all"
    - name: target_cluster
      value: "C011b88fa"
    - name: app_name
      value: "sample-petclinic"
    - name: app_id
      value: ""
    - name: artifact_url
      value: "http://github.com/robertchoi80/sample-petclinic/spring-petclinic-2.7.0-SNAPSHOT.jar"
    - name: image_url
      value: "REGISTRY/IMAGE:TAG"
    - name: port
      value: "8080"
    #######################
    # Deploy-only params? #
    #######################
    # executable path in the image
    - name: executable_path
      value: "JAR_PATH_IN_THE_IMAGE"
    - name: profile
      value: "default"
    # Possible values: tiny, medium, large
    - name: resource_spec
      value: "medium"
    - name: tks_info_host
      value: "tks-info.tks"

  templates:
  - name: exit-handler
    steps:
    - - name: parse-failed-step
        template: parse-failed-step
        when: "{{workflow.status}} != Succeeded"
# This expression syntax doesn't work at all as mentioned in the doc as always. Go to hell!
#    - - name: notify-failure
#        templateRef:
#          name: update-tks-asa-status
#          template: updateTksAsaStatus
#        arguments:
#          parameters:
#          - name: status
#            valueFrom:
#              expression: "steps['parse-failed-step'].outputs.parameters.step_name == build-image ? BUILD_FAILED : DEPLOY_FAILED"
#        when: "{{workflow.status}} != Succeeded"
    - - name: notify-build-failure
        templateRef:
          name: update-tks-asa-status
          template: updateTksAsaStatus
        arguments:
          parameters:
          - name: asa_id
            value: "{{workflow.parameters.app_id}}"
          - name: status
            value: "BUILD_FAILED"
          - name: output
            value: "{{workflow.outputs.parameters.build_output_global}}"
        when: "{{workflow.status}} != Succeeded && '{{steps.parse-failed-step.outputs.parameters.step_name}}' == 'build-image'"
    - - name: notify-deploy-failure
        templateRef:
          name: update-tks-asa-status
          template: updateTksAsaStatus
        arguments:
          parameters:
          - name: asa_id
            value: "{{workflow.parameters.app_id}}"
          - name: status
            value: "DEPLOY_FAILED"
          - name: output
            value: "{{workflow.outputs.parameters.deploy_output_global}}"
        when: "{{workflow.status}} != Succeeded && '{{steps.parse-failed-step.outputs.parameters.step_name}}' == 'deploy-app'"

  - name: main
    steps:
    - - name: build-image
        when: "{{workflow.parameters.task_type}} != 'deploy'"
        template: build-image
    - - name: notify-build-success
        templateRef:
          name: update-tks-asa-status
          template: updateTksAsaStatus
        arguments:
          parameters:
          - name: asa_id
            value: "{{workflow.parameters.app_id}}"
          - name: status
            value: "BUILD_SUCCESS"
          - name: output
            value: "{{steps.build-image.outputs.parameters.build_output}}"
    - - name: deploy-app
        when: "{{workflow.parameters.task_type}} != 'build'"
        template: deploy-app
    - - name: notify-deploy-success
        templateRef:
          name: update-tks-asa-status
          template: updateTksAsaStatus
        arguments:
          parameters:
          - name: asa_id
            value: "{{workflow.parameters.app_id}}"
          - name: status
            value: "DEPLOY_SUCCESS"
          - name: output
            value: "{{steps.deploy-app.outputs.parameters.deploy_output}}"
    - - name: update-endpoint-url
        templateRef:
          name: update-tks-asa-endpoint
          template: updateTksAsaEndpoint
        arguments:
          parameters:
          - name: asa_id
            value: "{{workflow.parameters.app_id}}"
          - name: endpoint
            value: "{{steps.deploy-app.outputs.parameters.endpoint}}"

  #######################
  # Template Definition #
  #######################
  - name: build-image
    volumes:
    - name: varrun
      emptyDir: {}
    - name: out
      emptyDir: {}
    sidecars:
    - name: dind
      image: 'docker:20.10.16-dind'
      volumeMounts:
      - mountPath: /var/run
        name: varrun
      securityContext:
        privileged: true
    outputs:
      parameters:
      - name: build_output
        valueFrom:
          path: /mnt/out/build_output.txt
        globalName: build_output_global
    container:
      #TODO: split worker image
      image: 'sktcloud/appserving-worker:latest'
      volumeMounts:
      - name: varrun
        mountPath: /var/run
      - name: out
        mountPath: /mnt/out
      env:
      - name: DOCKERHUB_TOKEN
        valueFrom:
          secretKeyRef:
            name: dockerhub-robert-token
            key: TOKEN
      command:
      - /bin/sh
      - '-exc'
      - |
        mkdir -p /apps && cd /apps/

        echo "Fetching app artifact.." | tee -a /mnt/out/build_output.txt

        # TODO: How to pass auth info here?
        curl -L -o {{workflow.parameters.app_name}}.jar {{workflow.parameters.artifact_url}}

        # fetch Dockerfile & manifests from git
        git clone https://github.com/openinfradev/app-serve-template.git

        cp -r ./app-serve-template/Dockerfile .
        ls -l .

        ###############
        # Build Image #
        ###############

        echo "Composing Dockerfile..." | tee -a /mnt/out/build_output.txt

        # Replace port number in Dockerfile
        sed -i "s/JARFILENAME/{{workflow.parameters.app_name}}.jar/g" ./Dockerfile
        sed -i "s/PORTNUM/{{workflow.parameters.port}}/g" ./Dockerfile

        # Debug
        cat Dockerfile | tee -a /mnt/out/build_output.txt
        echo "=== End of Dockerfile ===" | tee -a /mnt/out/build_output.txt

        # Give time for the docker daemon to start in sidecar
        sleep 5

        echo "Building container image..." | tee -a /mnt/out/build_output.txt
        # Build docker image
        image_name="{{workflow.parameters.image_url}}"
        docker build -t $image_name .

        # Login to dockerhub
        docker login -u robertchoi80 -p $DOCKERHUB_TOKEN

        # Push image
        echo "Pushing container image..." | tee -a /mnt/out/build_output.txt
        docker push $image_name 2>&1

  - name: deploy-app
    volumes:
    - name: out
      emptyDir: {}
    outputs:
      parameters:
      - name: deploy_output
        valueFrom:
          path: /mnt/out/deploy_output.txt
        globalName: deploy_output_global
      - name: endpoint
        valueFrom:
          path: /mnt/out/endpoint
    container:
      image: 'sktcloud/appserving-worker:latest'
      volumeMounts:
      - name: out
        mountPath: /mnt/out
      env:
      - name: DOCKERHUB_TOKEN
        valueFrom:
          secretKeyRef:
            name: dockerhub-robert-token
            key: TOKEN
      command:
      - /bin/sh
      - '-exc'
      - |
        mkdir -p /apps/

        # fetch manifests from git
        cd /apps
        git clone https://github.com/openinfradev/app-serve-template.git

        cp -r ./app-serve-template/* .
        ls -l .

        # Build manifest using kustomize
        echo "Building kustomize manifest..." | tee -a /mnt/out/deploy_output.txt
        kustomize build overlays/{{workflow.parameters.resource_spec}} > manifest.yaml

        # replace variable for the app
        echo "Replacing variables in the manifest..." | tee -a /mnt/out/deploy_output.txt
        image_name="{{workflow.parameters.image_url}}"
        sed -i "s#EXECUTABLE_PATH#{{workflow.parameters.executable_path}}#g" ./manifest.yaml
        sed -i "s/PORTNUM/{{workflow.parameters.port}}/g" ./manifest.yaml
        sed -i "s/APPNAME/{{workflow.parameters.app_name}}/g" ./manifest.yaml
        sed -i "s#IMAGEURL#${image_name}#g" ./manifest.yaml
        sed -i "s/PROFILE/{{workflow.parameters.profile}}/g" ./manifest.yaml

        # Debug
        cat manifest.yaml

        # Prepare kubeconfig
        echo "Preparing kubeconfig for target cluster..." | tee -a /mnt/out/deploy_output.txt
        KUBECONFIG_=$(kubectl get secret -n {{workflow.parameters.target_cluster}} {{workflow.parameters.target_cluster}}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
        if [[ -z "$KUBECONFIG_" ]]; then
          echo "Couldn't get kubeconfig for cluster {{workflow.parameters.target_cluster}}" | tee -a /mnt/out/deploy_output.txt
          exit 1
        fi

        echo "$KUBECONFIG_" > /etc/kubeconfig_temp
        export KUBECONFIG='/etc/kubeconfig_temp'

        # Deploy
        echo "Starting deployment..." | tee -a /mnt/out/deploy_output.txt
        kubectl apply -f ./manifest.yaml -n {{workflow.parameters.app_name}} | tee -a /mnt/out/deploy_output.txt

        # Wait for pod to be ready
        echo "Waiting for the deployment to be finished..." | tee -a /mnt/out/deploy_output.txt
        kubectl wait --for=condition=Available --timeout=300s -n {{workflow.parameters.app_name}} deploy/{{workflow.parameters.app_name}} | tee -a /mnt/out/deploy_output.txt

        # Temporary output until app-serving service is implemented
        # This msg will be sent to CLI by app-serviing service.
        echo "The app <{{workflow.parameters.app_name}}> has been deployed."

        # Get port number
        #$ kubectl get svc {{workflow.parameters.app_name}} -n {{workflow.parameters.app_name}} -o jsonpath='{.spec.ports[0].port}'"

        # Writing endpoint to file
        kubectl get svc {{workflow.parameters.app_name}} -n {{workflow.parameters.app_name}} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' > /mnt/out/endpoint
        echo ":{{workflow.parameters.port}}" >> /mnt/out/endpoint

  - name: parse-failed-step
    volumes:
    - name: out
      emptyDir: {}
    outputs:
      parameters:
      - name: step_name
        valueFrom:
          path: /mnt/out/failed_step_name.txt
    script:
      image: python:alpine3.8
      volumeMounts:
      - name: out
        mountPath: /mnt/out
      command: [python]
      source: |
        import time
        import json

        wf_failures = {{workflow.failures}}

        # convert string to list
        wf_failure_list = json.loads(wf_failures)
        print(type(wf_failure_list))

        failed_step=''
        for step in wf_failure_list:
          print("Processing str: {}".format(step))
          # step is 'dict' type now.
          if step["templateName"] == 'build-image' or step["templateName"] == 'deploy-app':
            print("found failed step {}".format(step["templateName"]))
            failed_step = step["templateName"]
            break

        if failed_step:
          print("Writing failed step name '{}' to file...".format(failed_step))
          with open('/mnt/out/failed_step_name.txt', 'w') as f:
            f.write(failed_step)
        else:
          print("Couldn't find failed step name!")
          exit(1)
